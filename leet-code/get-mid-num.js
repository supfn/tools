/**
 * 题目：给出一个元素无序的数组，求出一个数，使得其左边的数都小于它，右边的数都大于等于它。要求时间复杂度n。
 * 丰富细节：找出所有符合以下特点的数，返回它们的索引。
 *
 * 解题思路： 使用单调栈
 * 1. 当元素入栈的时候，单调栈只能保证入栈元素比栈内元素都大，但是不能保证是数组中出现过的最大的
 * 2. 所以额外需要一个最大值，来增强入栈规则
 * 3. 栈内的是满足【其左边的数都小于它】的条件，当右侧出现比其小的元素时 不满足【右边的数都大于等于它】，则出栈
 */

function getMidNum(arr) {
  let max = arr[0];
  let stack = [0];
  for (let i = 0; i < arr.length; i++) {
    let num = arr[i];

    // 当前元素为栈中元素的右侧元素，保证右边的数都大于等于
    while (stack.length && arr[stack[stack.length - 1]] > num) {
      stack.pop();
    }

    // 入栈元素大于【数组中出现过的最大值】，保证左边都小于
    if (num > max) {
      stack.push(i);
      max = num;
    }
  }
  return stack;
}

//用例：
// 输入：[3,2,1,4,7,6,5]
// 输出：[3]

// 输入：[2,1,3,4,5,7,6]
// 输出：[2,3,4]

// 输入：[7,6,5,4,3,2,1]
// 输出：[]

// 输入：[6,5,4,3,2,1,7]
// 输出：[6]

// 输入：[1,7,6,5,4,3,2]
// 输出：[0]

function test() {
  let arr = [3, 2, 1, 4, 7, 6, 5]
  console.log(getMidNum(arr))
}
test()